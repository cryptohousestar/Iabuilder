#!/usr/bin/env python3
"""
Test script to verify function calling format consistency issues.
"""

import sys
import json
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

def test_function_calling_consistency():
    """Test the inconsistency between system prompt and parsing code."""

    print('üß™ TEST: Function Calling Format Consistency')
    print('=' * 60)

    # Simulate AI response with correct JSON format (as per system prompt)
    mock_response_content = '{"tool_calls": [{"type": "function", "function": {"name": "read_file", "arguments": "{\\"file_path\\": \\"main.py\\"}" }}]}'

    class TestParser:
        def _extract_response_content(self, response):
            return mock_response_content

        def _parse_ai_function_calls(self, response):
            """Parse function calls generated by AI in <tool_name>{parameters} format."""
            try:
                # Extract response content
                content = self._extract_response_content(response)
                if not content:
                    return []

                tool_calls = []
                import re

                # Pattern to match <tool_name>{json_parameters}
                pattern = r'<(\w+)>\{([^}]+)\}'
                matches = re.findall(pattern, content)

                for tool_name, params_str in matches:
                    try:
                        # Parse JSON parameters
                        params = json.loads(f"{{{params_str}}}")

                        tool_calls.append({
                            'name': tool_name,
                            'parameters': params
                        })

                    except (json.JSONDecodeError, Exception):
                        continue
                return tool_calls

            except Exception as e:
                print(f"Error parsing AI function calls: {e}")
                return []

    parser = TestParser()

    print('üìã 1. System Prompt Format (CORRECT):')
    print('   {"tool_calls": [{"type": "function", "function": {"name": "tool_name", "arguments": "..."}}]}')
    print()

    print('üîç 2. Current Code Parsing (LOOKS FOR):')
    print('   <tool_name>{parameters}')
    print()

    # Test parsing
    parsed = parser._parse_ai_function_calls(None)
    print(f'üìä 3. Parsing Result: {len(parsed)} tool calls found')
    if parsed:
        print(f'   Found: {parsed}')
    else:
        print('   ‚ùå No tool calls parsed (expects <tool>{json} format)')
    print()

    # Test direct JSON parsing
    print('‚úÖ 4. Direct JSON Parsing Test:')
    try:
        json_parsed = json.loads(mock_response_content)
        tool_calls = json_parsed.get("tool_calls", [])
        print(f'   ‚úÖ Successfully parsed {len(tool_calls)} tool calls')

        if tool_calls:
            tc = tool_calls[0]
            func = tc.get("function", {})
            name = func.get("name")
            args = func.get("arguments")
            print(f'   Tool: {name}')
            print(f'   Args: {args}')

            # Parse the arguments string
            try:
                args_parsed = json.loads(args)
                print(f'   ‚úÖ Arguments parsed: {args_parsed}')
            except:
                print('   ‚ùå Could not parse arguments string')

    except Exception as e:
        print(f'   ‚ùå JSON parsing failed: {e}')

    print()
    print('üéØ CONCLUSION:')
    print('=' * 60)
    print('‚ùå PROBLEM: Inconsistency between system prompt and parsing code')
    print('   - System prompt tells model to use JSON format')
    print('   - Parsing code looks for <tool>{json} format')
    print('   - Model generates JSON ‚Üí Code finds nothing ‚Üí No tools used')
    print()
    print('üí° SOLUTION NEEDED:')
    print('   - Update parsing to handle JSON format from system prompt')
    print('   - Or update system prompt to match parsing code')
    print('   - Recommended: Use JSON format (standard for Groq/OpenAI)')

if __name__ == "__main__":
    test_function_calling_consistency()